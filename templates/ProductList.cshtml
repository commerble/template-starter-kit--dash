@model IDictionary<string, object>
@functions {
    public class ViewModel {
        public string ListName { get; set; }
        public bool HasNextPage { get; set; }
        public bool IsEmpty { get; set; }
        public int Page { get; set; }
        public List<ProductPageViewModel> ProductPages { get; set; }
        public List<CategoryViewModel> CheckedKinds { get; set; }
        public List<CategoryViewModel> CheckedTags { get; set; }
        public string Sort { get; set; }
        public string SearchCondition(string path, string removeKind = null, string removeTag = null) {
            return path + "?" + string.Join("&", CheckedKinds.Where(k => k.Code!=removeKind).Select(k => "k="+k.Code).Concat(CheckedTags.Where(t => t.Code!=removeTag).Select(t => "t="+t.Code)).Concat(new []{$"sort={Sort}"}));
        }
    }
    public class ProductPageViewModel {
        public string Code { get; set; }
        public string Kind { get; set; }
        public string KindName { get; set; }
        public string KindIcon { get; set; }
        public string Name { get; set; }
        public string Thumbnail { get; set; }
        public string Icon { get; set; }
        public int? PriceProductId { get; set; }
        public bool? HasMultiplePrice { get; set; }
        public decimal? UnitPriceWithTax { get; set; }
        public string PriceProductExternalId1 {get; set;}
        public string PriceProductName {get; set;}
    }
    public class CategoryViewModel {
        public string GroupCode { get; set; }
        public string Code { get; set; }
        public string Name { get; set; }
        public string Icon { get; set; }
    }
    ViewModel LoadViewModel() {
        var checkedKinds = ((Model.ContainsKey("kinds") ? Model["kinds"] as string[] : null) ?? new string[0]).Select(k => k.ToLower()).ToArray();
        var checkedTags  = ((Model.ContainsKey("tags")  ? Model["tags"]  as string[] : null) ?? new string[0]).Select(t => t.ToLower()).ToArray();
        var sort = Page.Request.QueryString["sort"] ?? "new";
        int page = int.TryParse(Page.Request.QueryString["page"], out page) ? page : 0;
        int eachPage = 12;
        var kinds = Kinds.Select(k => new CategoryViewModel {
            GroupCode = k.GroupCode,
            Code = k.Code.ToLower(),
            Name = k.Name,
            Icon = k.Icon,
        }).ToList();
        var tags = Tags.Select(t => new CategoryViewModel {
            GroupCode = t.GroupCode,
            Code = t.Code.ToLower(),
            Name = t.Name,
            Icon = t.Icon,
        }).ToList();
        var builder = 
            Database.Builder(db => 
                from p in db.ProductPages
                join rt in db.ProductTagRelations on p.Code equals rt.ProductPageCode into tagRelations
                from r in tagRelations.DefaultIfEmpty()
                where p.DisplayStart <= Now 
                   && (p.DisplayEnd == null || p.DisplayEnd > Now)
                   && (p.IsPublished || IsPreview)
                group new { p, r } by new { 
                    p.Code, 
                    p.Kind, 
                    p.ReleaseDate, 
                    p.RankingIndex, 
                    p.RecommendIndex, 
                    p.PriceIndex
                } into g
                select new {
                    ProductPageCode = g.Key.Code,
                    Kind = g.Key.Kind.ToLower(),
                    g.Key.ReleaseDate,
                    g.Key.RankingIndex,
                    g.Key.RecommendIndex,
                    g.Key.PriceIndex,
                    Tags = g.Select(o => o.r.ProductTagCode)
                }
            );

        if (checkedKinds.Length > 0) {
            builder.Append(query => query.Where(p => checkedKinds.Contains(p.Kind)));
        }

        foreach (var checkedTagGrouping in tags.Where(t => checkedTags.Contains(t.Code)).GroupBy(t => t.GroupCode??Guid.NewGuid().ToString())){
            var checkedTagGroupingCodes = checkedTagGrouping.Select(t => t.Code).ToArray();
            builder.Append(query => query.Where(p => p.Tags.Any(t => checkedTagGroupingCodes.Contains(t))));
        }

        builder.Append(query => query.Select(p => new {
            p.ProductPageCode,
            Kind = (string)null,
            p.ReleaseDate,
            p.RankingIndex,
            p.RecommendIndex,
            p.PriceIndex,
            Tags = (IEnumerable<string>)null,
        }).Distinct());
        
        switch (sort) {
            case "prc_asc":
                builder.Append(query=> query.OrderBy(p => p.PriceIndex));
                break;
            case "prc_desc":
                builder.Append(query=> query.OrderByDescending(p => p.PriceIndex));
                break;
            case "rkg_asc":
                builder.Append(query=> query.OrderBy(p => p.RankingIndex));
                break;
            case "rkg_desc":
                builder.Append(query=> query.OrderByDescending(p => p.RankingIndex));
                break;
            case "rcm_asc":
                builder.Append(query=> query.OrderBy(p => p.RecommendIndex));
                break;
            case "rcm_desc":
                builder.Append(query=> query.OrderByDescending(p => p.RecommendIndex));
                break;
            case "old":
                builder.Append(query=> query.OrderBy(p => p.ReleaseDate));
                break;
            case "new":
            default:
                sort = "new";
                builder.Append(query=> query.OrderByDescending(p => p.ReleaseDate));
                break;
        }

        var total = builder.Count(new { Now, Next, IsPreview, checkedKinds, checkedTags, sort });

        builder.Append(query => query.Skip(page * eachPage).Take(eachPage));
        var search = builder.Execute(new { Now, Next, IsPreview, checkedKinds, checkedTags, sort });
        var codes = search.Select(p => p.ProductPageCode).ToList();

        var items = 
            Database.Query(new { Now, Next, IsPreview }, db =>
                from p in db.ProductPages
                join rk in db.ProductKinds on p.Kind equals rk.Code into rkinds
                from k in rkinds.DefaultIfEmpty()
                join rs in db.Products on p.PriceProductId equals rs.Id into skus
                from s in skus.DefaultIfEmpty()
                where codes.Contains(p.Code)
                select new ProductPageViewModel {
                    Code = p.Code,
                    Kind = p.Kind,
                    KindName = string.IsNullOrEmpty(k.DisplayName) ? k.Name : k.DisplayName,
                    KindIcon = k.Icon,
                    Name = p.Name,
                    Thumbnail = p.Thumbnail,
                    Icon = p.Icon,
                    PriceProductId = p.PriceProductId,
                    HasMultiplePrice = p.HasMultiplePrice,
                    PriceProductExternalId1 = s.ExternalId1,
                    PriceProductName = s.Name
                }
            ).ToList();

        items = items.OrderBy(item => codes.IndexOf(item.Code)).ToList();
        
        foreach (var item in items) {
            if (item.PriceProductId.HasValue) {
                item.UnitPriceWithTax = Page.Template.GetUnitPriceWithTax(item.PriceProductId.Value);
            }
        }

        var listName = new string[]{ "Item" }.Concat(checkedKinds).Concat(checkedTags).ToList();
        listName.Add(eachPage.ToString());
        listName.Add(page.ToString());

        var pageCount = total / eachPage + ((total % eachPage == 0) ? 0 : 1);
        var pageLast = pageCount == 0 ? true : ( ((page+1) == pageCount) ? true : false);

        return new ViewModel {
            ListName = string.Join(":", listName),
            HasNextPage = total > 0 && !pageLast,
            IsEmpty = total == 0,
            Page = page,
            ProductPages = items,
            CheckedKinds = checkedKinds.Join(kinds, c => c, k => k.Code, (c,k) => k).ToList(),
            CheckedTags = checkedTags.Join(tags, c => c, t => t.Code, (c,t) => t).ToList(),
            Sort = sort,
        };
    }
}
@{
    var vm = LoadViewModel();
    ViewBag.DataLayer = new object[] { new {
        @event = "view_item_list",
        ecommerce = new {
            impressions = vm.ProductPages.Select((p, index) => new {
                item_name = p.PriceProductName,
                item_id = p.PriceProductExternalId1,
                price = p.UnitPriceWithTax?.ToString(),
                item_category = p.Kind,
                item_list_name = vm.ListName,
                item_list_id = vm.ListName,
                index = index + 1,
            })
        }
    }};
}
<div class="columns">
    <div class="col-3 col-order-2">
        <div class="block block-horizontal block-wrap">
            @foreach(var kind in vm.CheckedKinds) {
                <a class="badge badge-removal" href="@vm.SearchCondition(Href("~/search"), removeKind:kind.Code)">
                    @if (!string.IsNullOrEmpty(kind.Icon)) {
                        <i class="badge-icon @kind.Icon"></i>
                    }
                    @kind.Name
                </a>
            }
            @foreach(var tag in vm.CheckedTags) {
                <a class="badge badge-removal" href="@vm.SearchCondition(Href("~/search"), removeTag:tag.Code)">
                    #@tag.Name
                </a>
            }
        </div>
        @if (vm.CheckedKinds.Count == 0 && vm.CheckedTags.Count == 0 && vm.Page == 0) {
            <div class="block pc-hide">
                <a href="@(vm.SearchCondition(Href("~/search/condition")))" class="btn btn-default pc-hide">ğŸ” æ¤œç´¢æ¡ä»¶ã‚’å¤‰æ›´ã™ã‚‹</a>
            </div>
        }
        @TileList(vm.ProductPages, id:"result", slot:(item, index) =>
            ProductTile(
                item.Code,
                item.Name,
                item.KindName,
                item.KindIcon,
                item.Thumbnail ?? item.Icon,
                item.UnitPriceWithTax,
                item.HasMultiplePrice,
                gtm: new {
                    @event = "select_item",
                    ecommerce = new {
                        items = new [] {
                            new { 
                                item_name = item.PriceProductName,
                                item_id = item.PriceProductExternalId1,
                                item_category = item.Kind,
                                item_list_name = vm.ListName,
                                item_list_id = vm.ListName,
                                price = item.UnitPriceWithTax?.ToString("F0"),
                                index = index + 1,
                            } 
                        }
                    }
                } 
            )
        )
        @if (vm.IsEmpty) {
            <div class="message-box">
                <p class="message text-center lead">ã”å¸Œæœ›ã®æ¡ä»¶ã«åˆè‡´ã™ã‚‹å•†å“ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚æ¡ä»¶ã‚’å¤‰æ›´ã—å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚</p>
            </div>
        }
        @if (vm.HasNextPage) {
            <div class="block block-vertical">
                <a href="@(vm.SearchCondition(Page.Request.Url.AbsolutePath) + $"&page={(vm.Page+1)}")" class="btn btn-default btn-next">æ¬¡ã®ãƒšãƒ¼ã‚¸</a>
                <a href="@(vm.SearchCondition(Href("~/search/condition")))" class="btn btn-primary btn-text pc-hide">ğŸ” æ¤œç´¢æ¡ä»¶ã‚’å¤‰æ›´ã™ã‚‹</a>
            </div>
        }
    </div>
    <div class="col-1 col-order-1 sp-hide">
        @Include("SearchFilter", Model)
    </div>
</div>
